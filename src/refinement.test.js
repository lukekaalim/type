// @flow strict
const { assert } = require('@lukekaalim/test');
const { inspect } = require('util');
const { List } = require('immutable');
const { assertToDo } = require('./assertions.test');

const { generateConstraints } = require('./refinement');

const { areTypesCompatible } = require('./compatibility');

const { createProgramState } = require('./program');
const { createSimpleType } = require('./type');
const { createInstance } = require('./instance');
const { createConstraint } = require('./constraint');
const { createVariantRelationship, createIntersectionalRelationship } = require('./relationship');

const printConstraint = (typeNames, relationships) => ({ constrainedVariant, relationship }) => {
  const constrainedTypeName = typeNames.get(constrainedVariant) || '[unknown type]';
  const relationshipSubjectName =  typeNames.get(relationships.find(x => x.id === relationship).subject) || '[unknown type]';
  return `${relationshipSubjectName} => ${constrainedTypeName}`;
}

const testVariantRelationships = () => {
  const bengal = createSimpleType();
  const persian = createSimpleType();

  const cat = createSimpleType();
  const catRelationship = createVariantRelationship(cat.id, [bengal.id, persian.id]);
  const dog = createSimpleType();
  const rabbit = createSimpleType();

  const animal = createSimpleType();
  const animalRelationship = createVariantRelationship(animal.id, [cat.id, dog.id, rabbit.id])
  const plant = createSimpleType();

  const pet = createSimpleType();
  const petRelationship = createVariantRelationship(pet.id, [animal.id, plant.id]);

  const relationships = List([catRelationship, animalRelationship, petRelationship]);

  const state = createProgramState({
    relationships,
  });

  const myPet = createInstance(pet.id);
  const unconstrainedVariants = generateConstraints(state, myPet.id, pet.id, []);

  return assert('The variant constraints generated by generateConstraints() cover every permutation', [
    assert('There are 5 different states a pet could be (bengal, persian, dog, rabbit, plant)', [
      assert('The length of the array of states should be 5', unconstrainedVariants.length === 5)
    ]),
    assert('If a constraint (Animal === Cat), then we only generate constrains where that bond is true', [
      assert('The length of the array of states should be 3',
        generateConstraints(state, myPet.id, pet.id, [createConstraint(animalRelationship.id, cat.id)]).length === 3
      )
    ])
  ]);
};

const testIntersectionRelationships = () => {
  const one = createSimpleType();
  const zero = createSimpleType();

  const numeric = createSimpleType();
  const numericRelationship = createVariantRelationship(numeric.id, [one.id, zero.id]);

  const billy = createSimpleType();
  const dave = createSimpleType();

  const contactFor = createSimpleType();
  const contactForRelationship = createVariantRelationship(contactFor.id, [billy.id, dave.id]);

  const phoneNumber = createSimpleType();
  const phoneNumberRelationship = createIntersectionalRelationship(phoneNumber.id, [contactFor.id, numeric.id]);

  const relationships = List([phoneNumberRelationship, contactForRelationship, numericRelationship]);

  const myPhoneNumber = createInstance(phoneNumber.id);
  const state = createProgramState({
    relationships,
  });

  const typeMap = new Map([
    [one.id, 'one'],
    [zero.id, 'zero'],
    [numeric.id, 'numeric'],
    [billy.id, 'billy'],
    [dave.id, 'dave'],
    [contactFor.id, 'contactFor'],
    [phoneNumber.id, 'phoneNumber'],
  ]);

  const unconstrainedVariants = generateConstraints(state, myPhoneNumber.id, phoneNumber.id, []);

  return assert('The intersectional relationship should cause constrains to be generated for every variant this type intersects', [
    assert('There should be four different variants, since phoneNumber is intersecting with two binary variants (2 * 2)',
      unconstrainedVariants.length === 4
    ),
  ]);
};

const testRefinement = () => {
  return assert('The Type System should be able to refine abstract values into variants of constraints', [
    testVariantRelationships(),
    testIntersectionRelationships()
  ]);
};

module.exports ={
  testRefinement,
}