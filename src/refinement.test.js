// @flow strict
import test from '@lukekaalim/test';
const { assert } = test;

import { inspect } from 'util';
import immutable from 'immutable';
const { List } = immutable;
import { assertToDo } from './assertions.test.js';
import { createRefinementsForTypeId } from './refinement.js';
import { areTypesCompatible } from './compatibility.js';
import { createSimpleType } from './type.js';
import { createInstance } from './instance.js';
import { createConstraint } from './constraint.js';
import { createVariantRelationship, createIntersectionalRelationship } from './relationship.js';

const printConstraint = (typeNames, relationships) => ({ constrainedVariant, relationship }) => {
  const constrainedTypeName = typeNames.get(constrainedVariant) || '[unknown type]';
  const relationshipSubjectName =  typeNames.get(relationships.find(x => x.id === relationship).subject) || '[unknown type]';
  return `${relationshipSubjectName} => ${constrainedTypeName}`;
}

const testVariantRelationships = () => {
  const bengal = createSimpleType();
  const persian = createSimpleType();

  const cat = createSimpleType();
  const catRelationship = createVariantRelationship(cat.id, [bengal.id, persian.id]);
  const dog = createSimpleType();
  const rabbit = createSimpleType();

  const animal = createSimpleType();
  const animalRelationship = createVariantRelationship(animal.id, [cat.id, dog.id, rabbit.id])
  const plant = createSimpleType();

  const pet = createSimpleType();
  const petRelationship = createVariantRelationship(pet.id, [animal.id, plant.id]);

  const variantRelationships = List([catRelationship, animalRelationship, petRelationship]);

  const state = createProgramState({
    variantRelationships,
  });

  const unconstrainedVariants = createRefinementsForTypeId(state, pet.id, List([]));

  return assert('The variant constraints generated by createRefinementsForTypeId() cover every permutation', [
    assert('There are 5 different states a pet could be (bengal, persian, dog, rabbit, plant)', [
      assert('The length of the array of states should be 5', unconstrainedVariants.length === 5)
    ]),
    assert('If a constraint (Animal === Cat), then we only generate constrains where that bond is true', [
      assert('The length of the array of states should be 3',
        createRefinementsForTypeId(state, pet.id, List([createConstraint(animalRelationship.id, cat.id)])).length === 3
      )
    ])
  ]);
};

const testIntersectionRelationships = () => {
  const one = createSimpleType();
  const zero = createSimpleType();

  const numeric = createSimpleType();
  const numericRelationship = createVariantRelationship(numeric.id, [one.id, zero.id]);

  const billy = createSimpleType();
  const dave = createSimpleType();

  const contactFor = createSimpleType();
  const contactForRelationship = createVariantRelationship(contactFor.id, [billy.id, dave.id]);

  const phoneNumber = createSimpleType();
  const phoneNumberRelationship = createIntersectionalRelationship(phoneNumber.id, [contactFor.id, numeric.id]);

  const variantRelationships = List([contactForRelationship, numericRelationship]);
  const intersectionRelationships = List([phoneNumberRelationship]);

  const state = createProgramState({
    intersectionRelationships,
    variantRelationships,
  });

  const typeMap = new Map([
    [one.id, 'one'],
    [zero.id, 'zero'],
    [numeric.id, 'numeric'],
    [billy.id, 'billy'],
    [dave.id, 'dave'],
    [contactFor.id, 'contactFor'],
    [phoneNumber.id, 'phoneNumber'],
  ]);

  const unconstrainedVariants = createRefinementsForTypeId(state, phoneNumber.id, List());

  return assert('The intersectional relationship should cause constrains to be generated for every variant this type intersects', [
    assert('There should be four different variants, since phoneNumber is intersecting with two binary variants (2 * 2)',
      unconstrainedVariants.length === 4
    ),
  ]);
};

const testRefinement = () => {
  return assert('The Type System should be able to refine abstract values into variants of constraints', [
    testVariantRelationships(),
    testIntersectionRelationships()
  ]);
};

const exported = {
  testRefinement
};

export default exported;
export { testRefinement };